四、纯虚函数、抽象类和纯抽象类
1.形如virtual 返回类型 函数名 (形参表) [const] = 0;的虚函数被称为纯虚函数。纯虚函数不需要定义，表示抽象的行为。
2.如果一个类包含了至少一个纯虚函数，那么这个类就是抽象类。抽象类不能被实例化为对象。
3.如果子类没有覆盖其抽象基类中的全部纯虚函数，那么该子类就也是一个抽象类。类的抽象属性可以被继承。
4.如果一个抽象类中除了构造和析构函数以外所有的成员函数都是纯虚函数，那么该抽象类就是一个纯抽象类，有名接口类。
----------------------------------------------------------------------
class Browser {
public:
    void show (void) {
        // 提取一段文本
        onText ();
        // 提取一张图片
        onImage ();
        ...
    }
    virtual void onText (void) { ... }
    virtual void onImage (void) { ... }
    ...
};
class BrowserApple : public Browser {
public:
    virtual void onText (void) { ... }
    virtual void onImage (void) { ... }
    ...
};
BrowserApple ba;
ba.show ();
-----------------------------------------------------------------------
class Account {
public:
    Account (Database* db) : m_db (db) {}
    void save (double money) {
        ...
        m_db->select ();
        ...
        m_db->update ();
        ...
    }
private:
    Database* m_db;
};
class Database {
public:
    virtual void select (void) = 0;
    virtual void update (void) = 0; 
};
class Oracle : public Database {
public:
    void select (void) { ...Pro*C... }
    void update (void) { ... } 
};
class SQLServer : public Database {
public:
    void select (void) { ...ADO... }
    void update (void) { ... } 
};
Account acc (new Oracle);
Accoutn acc (new SQLServer);
-----------------------------------------------------------------------
五、虚函数表与动态绑定
1.编译器会为每个包含虚函数的类生成一张虚函数表，即存放每个虚函数地址的函数指针数组，简称虚表(vtbl)，每个虚函数对应一个虚函数表中的索引号。
2.除了为包含虚函数的类生成虚函数表以外，编译器还会为该类增加一个隐式的成员变量，通常在该类实例化对象的起始位置，用于存放虚函数表的首地址，该变量被称为虚函数表指针，简称虚指针(vptr)。
B b;
A& a = b;
a.foo (); // 被编译为：a.vptr[0] (&a)
              // vptr[0]中存放的就是B::foo地址
3.虚表是一个类一张，而不是一个对象一张，同一个类的所有对象，通过各自的虚指针，共享同一张虚表。
4.所谓虚函数覆盖，其本质就是用子类中的虚函数地址覆盖基类虚表中对应的基类虚函数的地址。
5.当编译器看到通过指针或引用调用虚函数的语句时，并不急于生成有关函数调用的指令，相反它会用一段代码替代该语句，这段代码在运行时被执行，完成如下操作：
1)从调用指针或引用的目标对象中找到虚指针；
2)根据虚指针找到相应的虚表，并从中获取所调用虚函数的入口地址；
3)根据虚函数的入口地址执行虚函数代码。
这个函数绑定过程在运行阶段完成，因此被称为动态绑定。
6.动态绑定对性能的影响
1)动态绑定会增加内存开销；
2)虚函数的调用会增加时间开销；
3)虚函数不能被内联优化。
如果没有多态性的要求，最好不要使用虚函数。
六、运行时类型信息
1.typeid运算符可以作用于类型或者对象(基本类型或类类型)，返回typeinfo类型对象的常引用。typeinfo中包含名为name的成员函数，调用该函数返回字符指针，该指针指向一个以空字符结尾的字符串，其中包含类型的标记。此外，typeinfo类提供了对“==”和“!=”运算符的支持，通过它们可以直接进行类型之间的比较。如果在类型之间存在多态的继承关系，typeid还可以利用多态性确定实际对象的类型。
#include <typeinfo>
2.dynamic_cast动态类型转换用于在具有多态继承关系的父子类指针和引用之间进行显式类型转换。在转换过程中，会检查指针或引用目标对象的类型是否与期望转换的类型一致，如果一致则转换成功，否则失败。如果所转换的是指针，则以返回空指针表示失败；如果所转换的是引用，则通过抛出bad_cast异常表示失败。
七、虚析构函数
1.delete一个指向子类对象的基类指针，实际被调用的仅仅是基类的析构函数。基类的析构函数只负责析构子类对象中的基类子对象，而不会调用子类的析构函数。这样在子类中动态分配的资源就会形成内存泄漏。
2.如果将基类的析构函数声明为虚函数，那么子类的析构函数就也是一个虚函数，并且对基类的虚函数构成有效的覆盖，可以表现出多态特性。这时delete一个指向子类对象的基类指针，实际被调用的将是子类的析构函数。子类的析构函数在释放子类对象特有的动态资源之后会自动调用基类的析构函数，释放基类子对象中的动态资源。最终实现完美的资源释放，避免了内存泄漏。
3.一般而言，如果一个类没有分配任何动态资源，可以不为其定义析构函数，但是编译器会为其提供缺省析构函数，而缺省析构函数不是虚函数。为了防止delete指向子类对象的基类指针时产生内存泄漏的风险，即使是空的析构函数也有为基类定义的必要，仅仅是为了通过虚析构在对象销毁过程中体现出多态特性。
八、类中哪些函数可以虚？
构造函数         不可以虚
析构函数         可以虚
普通成员函数   可以虚
静态成员函数   不可以虚
操作符函数      可以虚
===
异常
===
一、为什么需要异常？
1.程序不可能不出错
2.传统的错误处理机制存在缺陷
1)通过返回值表示错误
缺点：错误处理流程比较复杂，逐层判断，代码臃肿。
优点：函数调用路径中所有的局部对象(栈对象)都能被右花括号正确地析构，不会内存泄漏。
2)通过远程跳转处理错误
优点：不需要逐层判断，一步到位处理错误，代码精炼。
缺点：函数调用路径中的局部对象失去被析构机会，形成内存泄漏。
3.C++的异常结合两种传统错误处理的优点，同时规避了它们的缺省，既可以在形式上实现一步到位的错误处理，无需逐层判断返回值，同时又能保证所有局部对象得到正确的析构。




















