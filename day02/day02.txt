一、语言符号别名
ISO-646
{ - <%
} - %>
[ - <:
] - :>
# - %:
## - %:%:
&& - and
|| - or
! - not
!= - not_eq
& - bitand
&= - and_eq
| - bitor
|= - or_eq
^ - xor
^= - xor_eq
~ - compl
...
C95和C++98以后的语言标准都支持ISO-646别名规范。
二、函数的重载
1.什么是函数重载？
在同一个作用域中，函数名相同，参数表不同的函数，构成重载关系。
重载与函数的返回类型无关，与参数名也无关，而只与参数的个数、类型和顺序有关。
2.重载解析
根据调用函数时所提供的实参，按照类型匹配的原则，找到相应的重载版本的过程。
3.C++换名
C++编译器在编译C++函数时，会根据该函数的参数表对其名称进行替换，因此同一个作用域中参数表不同的同名函数，在编译成二进制目标模块以后，其函数名是不同的。
通过extern "C"关键字可以要求C++编译器按照C语言的方式生成函数接口，即不换名。
extern "C" void foo (int x, int y) { ... }
extern "C" {
void foo (int x, int y) { ... }
void bar (float x, double y) { ... }
...
}
当然，被extern "C"修饰的函数不能实现重载。
三、函数的缺省参数
1.在声明函数时可以为函数部分或全部参数指定缺省值，调用该函数时如果某些参数没有提供实参，那么该参数将取缺省值。
2.如果函数的某个参数带有缺省值，那么该参数后面的所有参数必须都带有缺省值。
3.避免缺省参数和重载发生歧义。
四、函数的内联
1.编译器用编译好的函数二进制代码块替换对该函数的调用指令的过程称为内联优化。借助内联优化，避免函数调用的开销，所付出的代价就是增大了可执行文件和进程空间代码区的字节数。
2.内联主要针对那些被频繁调用的简单函数。编译器会依据其内置的内联优化策略，根据函数的规模和被调用的频率，自动判断是否需要做内联优化。
3.若在函数定义前面，加上inline关键字，则可以显式告诉编译器，该函数希望进行内联优化。编译器会根据该函数实际的使用情况，决定是否满足程序员的要求。
inline void foo (void) { ... }
4.递归函数不可能被内联优化。
五、动态内存分配
1.兼容C语言的动态内存分配函数
malloc/calloc/realloc/free
2.C++增加了专门用于动态内存分配的运算符
1)new: 内存分配
2)delete/delete[]: 内存释放
如果用new分配数组，一定要用delete[]释放。
3)new分配内存失败，不会返回空指针(NULL)，而是抛出std::bad_alloc异常。如果程序没有捕获该异常，该异常将被系统捕获，并杀死引起此异常的进程。
---------------------------------------------------------------------
int a[3][4]; 3个int[4]
int *a[4]; // 指针数组，由指针组成的数组
int (*b)[4]; // 数组指针，指向数组整体的指针
先找变量名，从变量名出发，由近及远，先右后左，括号优先
char* (*p[4]) (int);
int a;
int a[5];
a
int[5]
---------------------------------------------------------------------
六、引用
1.引用即别名
int a = 10;
int& b = a; // b引用了a，b是a的别名，b就是a，a就是b
/*
int b = a;
*/
2.任何出现字面值常量、计算表达式、类型转换、函数返回值的场合，都会有临时变量(匿名变量)产生。只能用带有常属性(const)的引用引用这样的临时变量，而且一旦通过引用引用了临时变量，那么该变量的生命期就会从语句级别被提升为与该引用同寿。
3.引用必须做初始化，而且一经初始化其所引用的目标就不能更换。
4.引用型函数参数
1)如果函数的某个参数是引用，那么它就是该函数调用者实参的别名，对此引用的修改就是对其目标实参的修改，通过这种方法就可以从函数内部向其调用者输出数据。
2)通过引用向函数传递参数可以避免值传递所带来的内存复制开销，有助于提高传参的性能，但是也带来额外的风险，一旦在函数中修改了形参的值，也就等于修改了实参的值，如果这种修改并非预期，这种BUG就只能在运行阶段才会被发现。为了解决这个问题，可以将函数的参数定义为常引用，这样在函数中对常引用型参数的修改就会在编译阶段被暴露出来。
3)如果传递给函数的实参是临时变量，那么该函数的形参要么不用引用，要么就用常引用。