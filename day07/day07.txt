cout << sizeof (6 > 5.0) << endl;
A 1
B 4
C 8
D 不确定
C: B
C++: A
五、...
2.子类的析构函数
1)子类的析构函数，无论是自己定义的，还是系统缺省提供的，在执行完其中的析构代码，并析构完所有类类型成员子对象以后，一定会自动调用其基类的析构函数，析构该子类对象中的基类子对象。
构造：分配内存->调用子类的构造函数
                                       V
                           调用基类的构造函数
                             (按继承表的顺序)
                                       V
                调用的成员子对象类型的构造函数
                             (按声明的顺序)
                                       V
                           执行子类的构造代码
析构：                 执行子类的析构代码
                                       V
                调用成员子对象类型的析构函数
                             (按声明的逆序)
                                       V
                         调用基类的析构函数 -> 释放内存
                             (按继承的逆序)
2)基类的析构函数永远不可能调用子类的析构函数。对一个指向子类对象的基类指针使用delete运算符，实际被调用的基类析构函数，该函数不会调用子类的析构函数，所释放的仅仅是基类子对象中动态分配的资源，子类特有的动态资源将形成内存泄漏。
class A { ... };
class B : public A { ... };
A* pa = new B (...); // pa: 指向子类对象的基类指针
delete pa; // 调用A的析构函数
3.子类的拷贝构造
1)子类没有定义拷贝构造函数
系统为子类提供缺省拷贝构造函数，该函数会自动调用基类拷贝构造函数，初始化子类对象中基类子对象。
2)子类定义了拷贝构造函数，但是没有显式指明对基类拷贝构造
子类对象中的基类子对象将按照缺省方式初始化。
3)子类定义了拷贝构造函数，同时显式指明对基类也做拷贝构造
子类对象中的基类子对象将以拷贝方式做初始化。
4.子类的拷贝赋值
1)子类没有定义拷贝赋值运算符函数
系统提供的缺省拷贝赋值运算符函数自动调用基类的拷贝赋值运算符函数，复制基类子对象。
2)子类定义了拷贝赋值运算符函数，但是没有复制基类部分
基类子对象保持赋值之前的状态。
3)子类定义了拷贝赋值运算符函数，同时也复制了基类部分
基类子对象也会得到复制。
六、多重继承
1.一个子类可以同时继承自多个基类，这样的继承方式谓之多重继承。
学生    教师
      \  /
    科代表
技术人员     经理     销售人员    
            \   /      \   /
      技术主管    销售主管
电话  播放器  计算机
      \     |      /
       智能手机
2.名字冲突问题
一个子类的多个基类中如果存在相同的名字，当通过子类访问这些名字时，编译器会报告歧义错误――名字冲突。解决名字冲突的一般做法就是显式地通过作用域限定符指明所访问的名字继承自哪个基类。如果产生冲突的名字是成员函数且满足重载的条件，则可以通过using声明，在子类中形成重载关系，通过重载解析解决冲突。
3.钻石继承问题
1)一个子类的多个基类源自共同的基类祖先，这样的继承结构被称为钻石继承。
     人类
      /  \
学生    教师
      \  /
    科代表
                  员工
               _/   |  \_
            /       |      \
技术人员     经理     销售人员    
            \   /      \   /
      技术主管    销售主管
2)派生多个中间子类(B和C)的公共基类(A)子对象，在继承自多个中间子类的汇聚子类(D)对象中，存在多个实例。在汇聚子类中，或通过汇聚子类对象，访问公共基类的成员，会因继承路径的不同而导致不一致。
3)通过虚继承可以令公共基类子对象在汇聚子类对象中的实例唯一，并为所有中间子类对象所共享。这样即使沿着不同的继承路径，所访问到的公共基类成员一定是一致的。
===
多态
===
                  图形(位置/绘制)
                         /     \
矩形(长和宽/绘制)      圆形(半径/绘制)
一、虚函数、覆盖和多态
如果将基类中的某个成员函数声明为虚函数，那么其子类中与该函数具有相同原型的成员函数就也是虚函数，并且对基类中的版本形成覆盖。这时，通过指向子类对象的基类指针，或者引用子类对象的基类引用，调用虚函数，实际被执行的将是子类中的覆盖版本，而非基类中的原始版本，这种语法现象被称为多态。
二、虚函数覆盖的条件
1.只有类的成员函数才能被声明为虚函数，全局函数和类的静态成员函数都不能被声明为虚函数。
2.只有在基类中被冠以virtual关键字的成员函数才能作为虚函数被子类覆盖，而与子类中virtual关键字无关。
3.虚函数在子类中的覆盖版本必须和该函数在基类中原始版本拥有相同的函数签名，即函数名、形参表和常属性必须严格一致。
4.如果基类中的虚函数返回除类类型指针和引用以外的数据，那么该函数在子类中的覆盖版本必须返回相同类型的数据。
5.如果基类中的虚函数返回类类型的指针(X*)或引用(X&)，那么允许子类中的覆盖版本返回基类版本返回类型(X*/X&)的目标类型(X)的公有子类(Y)指针(Y*)或引用(Y&)――类型协变。
6.虚函数在子类中的覆盖版本和基类中的原始版本的访问控制属性没有必然联系。
三、多态的条件
1.多态特性除了需要在基类中声明虚函数，并在子类中提供有效的覆盖以外还必须通过指针或者引用来调用虚函数，才能表现出来。
2.调用虚函数的指针也可能是成员函数中的this指针，只要它是一个指向子类对象的基类指针，同样可以表现出多态性。
3.当基类的构造函数被子类的构造函数调用时，子类对象尚不能说是子类类型的，它只表现出基类类型的外观和行为。这时调用虚函数，它只能被绑定到基类版本，没有多态性。
4.当基类的析构函数被子类的析构函数调用时，子类对象已不再是子类类型的了，它只表现出基类类型的外观和行为。这时调用虚函数，它只能被绑定到基类版本，没有多态性。
5.在构造或析构函数中通过已构造完毕或尚未被析构的对象调用虚函数，其多态性不受任何影响。