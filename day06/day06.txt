综合案例：实现3X3矩阵类M33，支持典型的双目和单目运算符。
三、...
6.new/delete操作符
四、操作符重载的限制
1.不是所有的操作符都能重载，下列操作符不能重载：
1)作用域限定操作符(::)
2)直接成员访问操作符(.)
3)直接成员指针解引用操作符(.*)
4)条件操作符(?:)
5)字节长度操作符(sizeof)
6)类型信息操作符(typeid)
2.如果一个操作符所有的操作数都是基本类型，则该操作符无法被重载。
int operator+ (int a, int b) { return a - b; }
int x = 1 + 1;
cout << x << endl; // 0
3.操作符重载不会改变编译器预定义的优先级。
class Integer { ... };
Integer const operator^ (Integer const& x, int y) {
    Integer z (1);
    for (int i = 0; i < y; ++i)
        z.m_i *= x.m_i;
    return z;
}
d = a + b ^ c; // d = (a + b) ^ c;
4.操作符重载无法改变操作数的个数。
double operator% (Integer const& opd) {
    return opd.m_i / 100.0;
}
double x = 50%; // x : 0.5
5.无法通过操作符重载发明新的操作符。
Double const operator@ (Double const& a, Double const& b) {
    return Double (sqrt (a.m_d * a.m_d + b.m_d * b.m_d));
}
Double c = 3.0 @ 4.0; // c : 5.0
===
继承
===
结构化程序设计：顺序、分支和循环。
面向对象程序设计：封装、继承和多态。
一、继承的基本概念
第一级抽象：从具体的对象抽象出共同的属性和行为。
学生：姓名、年龄、学号、吃饭、睡觉、学习
教师：姓名、年龄、工资、吃饭、睡觉、授课
第二级抽象：将类型之间共性抽取出来形成超集，将类型之间的个性具体化的不同子集中。
人类：姓名、年龄、吃饭、睡觉     - 超集体现共性 - 基类  | 派生 ^
学生是人类的一部分：学号、学习  \ 子集              - 子类 V         | 继承
教师是人类的一部分：工资、授课  / 体现个性
二、继承的语法形式
class Human {
public:
    void eat (string const& food) { ... }
    void sleep (int durations) { ... }
private:
    string m_name;
    int m_age;
};
class Student : public Human {
public:
    void learn (string const& course) { ... }
private:
    int m_no;
};
class Teacher : public Human {
public:
    void teach (string const& course) { ... }
private:
    double m_salary;
};
Student s (...);
s.eat ("KFC");
s.sleep (1);
s.learn ("C++");
Teacher t (...);
t.eat ("狗不理");
t.sleep (10);
t.teach ("UC");
class 子类 : 继承方式1 基类1, 继承方式2 基类2, ... { ... };
                ^^^^^^^^^^^^^^^^^^^^^^^^
                                        继承表
三、公有(继承方式为public)继承的基本特点
1.皆然性
1)逻辑结构：任何时候子类对象都可以被看做是基类对象。
   学生―是―人
   教师―是―人
   子类和基类的关系：ISA，是一个。
   从逻辑上看，基类的范畴不小于子类。
2)物理结构：任何时候基类的子类对象一定都是其基类子对象的父对象。
   从物理上看，子类对象的范围不小于基类对象。
2.向上和向下造型
1)向上造型：将子类类型的指针或引用转换基类类型指针或引用。这种操作性缩小的类型转换，在编译器看来是安全的。因此可以隐式完成。
2)向下造型：将基类类型的指针或引用转换子类类型指针或引用。这种操作性放大的类型转换，在编译器看来是危险的。因此必须显式完成。
3)编译对类型安全所做的检测，仅仅基于指针或引用本身的数据类型，而与其实际目标对象无关。基类指针或引用实际目标对象的类型，究竟是否与需要转换的指针或引用的目的类型一致，完全由程序员自己判断。如果一致，则可以通过静态类型转换static_cast显式地完成向下造型。
3.子类继承基类的成员
1)在子类中或通过子类，可以直接访问基类中的所有公有和保护成员，就如同它们是在子类中声明的一样。
2)基类的私有成员在子类虽然存在但是却不可见，故无法直接访问，但是通过基类提供的公有或者保护接口可以间接访问。
3)基类的构造函数和析构函数，子类是无法继承的，但是可以在子类自己的构造函数中显式指明其基类部分的初始化方式。
4.子类隐藏基类的成员
1)尽管基类的公有和保护成员在子类中直接可见，但仍然可以在子类中重新定义这些名字，子类中的名字会隐藏基类中同名定义。
2)如果需要在子类中或通过子类访问一个在基类中定义却被子类所隐藏的名字，可以借助作用域限定操作符“::”显式指明。
四、继承方式与访问控制
1.C++为类的成员提供了三种访问控制限定符：public、protected和private，影响访问该类成员的主体和位置。
访问控制    访问控制    内部    子类    外部     友元
限  定 符    属       性    访问    访问    访问     访问
public       公有成员    OK      OK      OK      OK
protected 保护成员     OK      OK      NO     OK
private      私有成员     OK      NO      NO    OK
2.C++为子类提供了三种从基类继承的方式：public、protected和private，影响通过子类访问基类中的成员的可访问性。
基类中的  在公有子  在保护子  在私有子
               类中变成  类中变成  类中变成
公有成员  公有成员  保护成员  私有成员
保护成员  保护成员  保护成员  私有成员
私有成员  私有成员  私有成员  私有成员
3.私有继承和保护继承
class DCT {
public:
    void codec (void) { ... }
}; // $100
class Jpeg : protected DCT {
public:
    void render (void) {
        ...
        codec ();
        ...
    }
};
class Jpeg2000 : public Jpeg {
public:
    void render (void) {
        ...
        codec (); // Ok
        ...
    }
};
------------------------------
Jpeg jpeg (...); // RMB1.00
jpeg.render ();
...
jpeg.codec (); // No
...
私有继承，又称实现继承，防止基类中的公有接口从子类中扩散出去。而保护继承仅仅防止基类中的公有接口向继承链外部扩散，但是对继承链内部的子类不做限制。
五、子类的构造、析构和拷贝
1.子类的构造函数
1)如果子类的构造函数没有显式指明其基类子对象的初始化方式，那么编译器一定会调用基类的缺省构造函数初始化该子对象。
2)如果希望子类对象的基类部分以有参的方式被初始化，就需要在子类构造函数的初始化表(而非函数体)中显式指明其基类子对象的初始化方式。