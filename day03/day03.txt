六、
...
5.引用型函数返回值
1)左值和右值
左值：可以放在赋值运算符左边的。可以被修改的。可以被取地址的。
int i;
i = 10;
++i;
int* p = &i;
右值：只能放在赋值运算符右边的。不可被修改的。不可被取地址的。
字面值常量：10 = i; --10; int* p = &10; // 错误
表达式的值：a + b = c; (a+b)++; int* p = &(a+b); // 错误
值形式的函数返回值：int foo (void) { ... }
foo () = 10; ++foo (); int* p = &foo (); // 错误
2)如果一个函数返回类型被声明为引用，那么该函数的返回值就是一个左值。注意该引用的目标一定要在函数返回以后依然有效，否则其值将是未定义的。
3)为了避免从函数返回值所带来的内存复制开销，可以将函数的返回类型声明为引用，同时为了避免在函数外部修改函数返回引用的目标变量，可以为该引用附加常属性。
6.引用和指针
1)指针可以只定义不初始化，但是引用必须在定义的同时初始化。
int i;
int* p; // 只定义不初始化
// p是危险的东西
// *p = 100; // 段错误
p = &i;
--------
int i;
int& r = i; // 比指针安全
2)指针的目标可以更换，但引用的目标不能更换。
int i, j;
int* p = &i; // p -> i
p = &j; // p -> j
--------
int i, j;
int& r = i; // r -> i
r = j; // j的值赋给i
3)可以定义指向指针的指针，但是不能定义引用引用的引用，没有高级引用
int* p;
int** pp = &p; // pp -> p
---------
int i;
int& r = i;
int&& rr = r; // 错误
在2011标准中类似int&&的写法是合法的，但是它并不表示二级引用，而是表示右值引用。
4)可以定义存放指针的数组，但是不能定义存放引用的数组，可以定义引用数组的引用。
int a, b, c;
int* pa[] = {&a, &b, &c};
-----------
int a, b, c;
int& ra[] = {a, b, c}; // 错误
int arr[] = {1, 2, 3};
int (&ra)[3] = arr; // 数组的引用
7.引用实际上就是通过指针实现的。
七、显式类型转换
int i = 3.2; // 隐式转换
char c = (char)1024; // 显式转换
1.C风格的类型转换C++完全兼容。
2.C++新增了四个显式类型转换运算符。
1)静态类型转换：static_cast<目标类型>
A.将基类的指针或引用转换为子类的指针或引用；
B.自定义类型转换。
2)动态类型转换：dynamic_cast<目标类型>
将基类的指针或引用转换为子类的指针或引用，在运行期检查基类指针或引用的目标对象是否真的是所要转换的子类类型。
3)常量类型转换：const_cast<目标类型>
去除或添加指针或引用的常属性。
4)重解释类型转换：reinterpret_cast<目标类型>
A.任意类型的指针或引用之间进行转换；
B.在指针和整数之间进行转换。
八、类和对象
1.何为对象？
任何一种事物都可被视为对象。
2.如何表达对象？
通过对象的属性(名字、数量词、形容词)和行为(动词、动词词组)表达对象。
3.面向对象程序设计
对自然世界的观察引入到编程实践中的一种理念和方法。
4.什么类？
类就是对对象属性的抽象。
    属性 行为
狗 犬种 进食
    犬龄 睡眠
    体重 玩耍
    毛色
学 姓名 吃饭
生 年龄 睡觉
    学号 学习
手 品牌 接打电话
机 型号 收发短信
    价格 上网
            玩游戏
现实世界                   类                       虚拟世界
具体对象 -抽象-> 属性/行为 -实例化-> 具体对象
围绕具体问题对属性和行为进行有意识的选择，使复杂的具体问题得到简化――面向对象的程序设计。
面向过程关注事件流程，而面向对象关注事件主体。
struct Dog {
    // 成员变量――属性
    char breed[256]; // 犬种
    int age; // 犬龄
    float weight; // 体重
    COLOR color; // 毛色
    // 成员函数――行为
    void eat (string const& food); // 进食
    void sleep (int duration); // 睡眠
    void play (void); // 玩耍
};
Dog dog = {"吉娃娃", 1, 0.5, BROWN};
dog.eat ("骨头");
dog.sleep (1);
dog.play ();
一条一岁大，半公斤重的棕色吉娃娃，啃了一块骨头，睡了一个小时，愉快地去玩耍。
九、类的定义与实例化
1.类的一般形式
class/struct 类名 : 继承方式 基类, ... {
访问控制限定符:
    类名 (形参表) : 成员变量 (初值), ... { // 构造函数
        函数体;
    }
    ~类名 (void) { // 析构函数
        函数体;
    }
    返回类型 函数名 (形参表) 常属性 异常说明 { // 成员函数
        函数体;
    }
    数据类型 变量名; // 成员变量
};
2.访问控制限定符
1)公有成员――public
谁都可以访问。
2)私有成员――private
只有该类自己的成员函数可以访问。
3)保护成员――protected
只有该类及其子类的成员函数可以访问。
在C++中类(class)和结构体(struct)已经没有本质性的区别了，唯一的不同就是类的缺省访控属性为私有，而结构体的缺省访控属性为公有。
3.构造函数
1)函数名与类名相同，且没有返回类型。
2)构造函数在对象被创建时自动被调用。
3)构造函数负责确定对象的初始状态以及分配必要的资源。
4)构造函数在每个对象的整个生命周期内，一定会被调用，且仅被调用一次。
5)对象的创建过程：
A.首先为对象分配足量的内存空间；
B.以构造实参调用构造函数，完成如下任务：
a)依次调用各个基类的构造函数，初始化所有基类子对象；
b)依次调用类类型成员的构造函数，初始化所有成员子对象；
c)执行构造函数体代码。
4.对象的创建与销毁
1)在栈中创建单个对象
类名 对象 (构造实参表);
Student s1 ("张飞", 22, 1001);
类名 对象 = 类名 (构造实参表);
Student s1 = Student ("张飞", 22, 1001);
2)在栈中创建对象数组
类名 对象数组[元素个数] = {类名 (构造实参表), ...};
Student sa[3] = {
    Student ("张飞", 22, 1001),
    Student ("赵云", 20, 1002),
    Student ("关羽", 25, 1003)};
3)在堆中创建/销毁单个对象
创建：类名* 对象指针 = new 类名 (构造实参表);
Student* ps = new Student ("张飞", 22, 1001);
new运算符首先分配内存空间，然后调用构造函数完成对该对象的初始化。malloc只能分配内存，不会调用构造函数。
销毁：delete 对象指针;
delete ps;
4)在堆中创建/销毁对象数组
创建：类名* 对象指针 = new 类名[元素个数] {类名 (构造实参表), ...};
这种初始化语法需要C++2011标准支持。
销毁：delete[] 对象指针;
十、构造函数与初始化表
1.构造函数可以通过差别化参数表实现重载，以表示对象的不同初始化方式。重载构造函数通过构造实参的类型选择匹配的版本。
2.如果一个类中没有显式地定义任何构造函数，那么编译器就会为该类提供一个缺省构造函数：
1)对于基本类型的成员变量，不做初始化；
2)对于类类型的成员变量，调用相应类型的缺省构造函数初始化。
只要为一个类定义了构造函数，无论它是否是缺省构造函数，编译器都不再提供缺省构造函数了。
3.拷贝构造函数
1)当用一个已存在的对象构造与之同类型的副本对象时，会调用该类型的拷贝构造函数。
2)拷贝构造函数负责将源对象中的成员变量逐个复制给目标对象中的对应成员变量。
3)如果一个类中没有显式定义拷贝构造函数，那么编译器就会为该类提供一个缺省拷贝构造函数：
A.对于基本类型的成员变量，按字节复制；
B.对于类类型的成员变量，调用相应类型的拷贝构造函数。
多数情况下，编译器提供的缺省拷贝构造函数已经足够适用，程序员无需自行定义，但是某些情况下，缺省拷贝构造函数不能满足特殊的需要，必须提供自定义的拷贝构造函数。